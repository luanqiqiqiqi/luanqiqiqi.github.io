<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>文字展示页面</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* 核心：主容器 - 承载所有元素，配置本地背景图 */
        .container {
            position: relative; /* 作为动态文字绝对定位的参考容器 */
            width: 100vw; height: 100vh; 
            overflow: hidden; /* 防止动态文字超出可视区域 */
            /* 背景图配置：Windows路径转义（反斜杠→正斜杠），保证路径可识别 */
            background-image: url('123.jpg');
            background-size: cover; /* 背景图铺满容器 */
            background-position: center; /* 背景图居中显示 */
            background-repeat: no-repeat; /* 背景图不重复 */
        }

        /* 核心：静止文字容器 - 网格布局实现100个文字10×10整齐排列 */
        .static-text-container {
            display: grid;
            grid-template-columns: repeat(10, 1fr); /* 10列等宽布局 */
            gap: 15px; /* 文字间距，保证排列整齐 */
            padding: 20px;
            width: 100%; height: 100%;
            background-color: rgba(255, 255, 255, 0.1); /* 半透明遮罩，提升文字可读性 */
        }

        /* 静止文字基础样式 */
        .static-text {
            color: #000; font-size: 30px;
            text-align: center; line-height: 1;
            text-shadow: 0 0 3px rgba(255, 255, 255, 0.8); /* 文字阴影，适配背景图 */
        }

        /* 核心：动态文字样式 - 绝对定位+大号字体，实现自由移动 */
        .dynamic-text {
            position: absolute; /* 脱离文档流，可自由定位 */
            font-size: 40px; font-weight: bold; /* 大号文字，突出显示 */
            pointer-events: none; /* 防止遮挡鼠标/音频控件操作 */
            transition: color 0.3s ease; /* 颜色切换渐变，更自然 */
        }

        /* 核心：音频控件 - 固定底部，手动播放控制 */
        .audio-player {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%); /* 水平居中 */
            z-index: 9999; /* 保证在最上层，不被遮挡 */
            background-color: rgba(0, 0, 0, 0.7); padding: 8px 15px;
            border-radius: 30px; /* 美化样式 */
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 静止文字容器 -->
        <div class="static-text-container" id="staticContainer"></div>
        
        <!-- 核心：音频播放控件 - controls显示播放/暂停/音量等按钮，preload="none"不预加载 -->
        <div class="audio-player">
            <audio controls preload="none">
                <source src="haoting.mp3" type="audio/mpeg"> <!-- 音频文件路径，需替换为实际路径 -->
                您的浏览器不支持HTML5音频播放！
            </audio>
        </div>
    </div>

    <script>
        // ===================== 核心：生成100个静止的"废物周某" =====================
        const staticContainer = document.getElementById('staticContainer');
        // 循环100次，生成10×10排列的静止文字
        for (let i = 0; i < 100; i++) {
            const textElement = document.createElement('div');
            textElement.className = 'static-text';
            textElement.textContent = '废物周某';
            staticContainer.appendChild(textElement);
        }

        // ===================== 核心：动态文字核心配置 =====================
        const dynamicCount = 4; // 设定4个动态文字
        const container = document.querySelector('.container');
        let containerWidth = container.clientWidth; // 容器宽度，用于边界检测
        let containerHeight = container.clientHeight; // 容器高度，用于边界检测
        const dynamicTexts = []; // 存储动态文字的状态（位置、速度等）

        // 核心：生成随机RGB颜色，用于动态文字颜色变换
        function getRandomColor() {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            return `rgb(${r}, ${g}, ${b})`;
        }

        // 核心：初始化单个动态文字（位置、速度、颜色）
        function initDynamicText() {
            const textElement = document.createElement('div');
            textElement.className = 'dynamic-text';
            textElement.textContent = '废物周某';
            
            // 文字宽高预估，避免初始位置超出容器
            const textWidth = 120;
            const textHeight = 50;
            // 随机初始位置（保证文字完全在容器内）
            const x = Math.random() * (containerWidth - textWidth);
            const y = Math.random() * (containerHeight - textHeight);
            // 随机移动速度（1-2px/帧，速度较慢），正负值控制移动方向
            const dx = (Math.random() - 0.5) * 4;
            const dy = (Math.random() - 0.5) * 4;

            // 初始化位置和颜色
            textElement.style.left = `${x}px`;
            textElement.style.top = `${y}px`;
            textElement.style.color = getRandomColor();

            container.appendChild(textElement);

            // 存储文字状态，用于动画循环更新
            dynamicTexts.push({
                element: textElement,
                x, y, dx, dy, width: textWidth, height: textHeight
            });
        }

        // 初始化4个动态文字
        for (let i = 0; i < dynamicCount; i++) {
            initDynamicText();
        }

        // ===================== 核心：动画循环 - 动态文字移动/反弹/变色 =====================
        function animate() {
            dynamicTexts.forEach(item => {
                // 1. 更新位置：按设定速度移动
                item.x += item.dx;
                item.y += item.dy;

                // 2. 边界检测：碰到容器边缘反弹（防止文字移出可视区域）
                if (item.x <= 0 || item.x >= containerWidth - item.width) {
                    item.dx = -item.dx; // 水平方向反弹（速度取反）
                }
                if (item.y <= 0 || item.y >= containerHeight - item.height) {
                    item.dy = -item.dy; // 垂直方向反弹（速度取反）
                }

                // 3. 应用新位置到DOM元素
                item.element.style.left = `${item.x}px`;
                item.element.style.top = `${item.y}px`;

                // 4. 随机更换颜色（约每0.5秒换一次，概率控制）
                if (Math.random() < 0.03) {
                    item.element.style.color = getRandomColor();
                }
            });

            requestAnimationFrame(animate); // 持续执行动画，保持60帧/秒
        }

        // 启动动画循环
        animate();

        // 核心：窗口大小变化时更新容器尺寸，保证动态文字边界检测准确
        window.addEventListener('resize', () => {
            containerWidth = container.clientWidth;
            containerHeight = container.clientHeight;
        });
    </script>
</body>

</html>

